# 01 강 DBMS 아키텍처 개요
---

![[Pasted image 20231009212047.png]]

## 쿼리 평가 엔진
- SQL 구문 분석 및 데이터 접근 순서 결정
	- 데이터에 어떻게 접근할지 세우는 계획을 `실행 계획`(또는 실행 플랜)이라고 함
	- 실행 계획에 따라 성능과 연관이 있음

## 버퍼 매니저
- 버퍼 메모리 영역을 관리
- 디스크 용량 매니저와 함께 연동하며 작동
 -> 마찬가지로 성능과 연관이 있음

## 디스크 용량 매니저
- 데이터의 저장 위치 관리 및 데이터의 읽기, 쓰기 제어

## 트랜잭션 매니저와 락 매니저
- 트랜잭션의 정합성 유지 및 실행
- 락 관리

## 리커버리 매니저
- 데이터 백업 및 복구

# 02 강 DBMS와 버퍼
---

> 버퍼는 성능에 중요한 영향을 미친다!

## 공짜 밥은 존재할까?
- 하드디스크는 큰 용량을 저장할 수 있지만 느리고, 메모리는 빠르지만 비싸다!

## DBMS와 기억장치

### DBMS가 데이터를 왜 메모리에 저장할까?
- 메모리에 많은 양을 저장하지 못하는데 왜 일부라도 저장할까? 그 답은 `성능 향상` 때문이다.
- 자주 접근하는 데이터를 메모리에 올려두면 디스크에서 검색할 필요 없이 빠르게 데이터를 검색할 수 있다.
> 일반적인 SQL 구문의 실행 시간 대부분은 저장소 I/O이다.

### 버퍼, 캐시
- 성능 향상을 목적으로 데이터를 저장하는 메모리

## DMBS의 메모리 공간

### 데이터 캐시
- SQL의 실행 속도를 빠르게 하기 위한 저장 공간
- 해당 공간에 찾는 데이터가 존재하면 빠르게 조회 가능

### 로그 버퍼
- 갱신 처리를 하기 전 변경 정보를 저장하는 공간
- 성능을 위해 비동기로 갱신 처리 진행
	- 갱신은 비교적 오래 걸리는 작업으로 사용자에게 일단 완료 메시지를 보내고 내부적으로 갱신 수행

![[Pasted image 20231010144256.png]]

## 메모리의 휘발성
> 메모리는 전원이 꺼지면 데이터를 저장할 수 없다.
### 로그 버퍼의 데이터는 정합성을 어떻게 보장할 수 있을까?
- 로그 버퍼에 있는 데이터가 디스크에 반영되기 전에 장애가 발생하면(전원이 꺼지는 등) 데이터가 삭제되는 문제가 발생할 수 있다.
- 이를 해결하기 위해 DBMS는 커밋 시점에 반드시 갱신 정보를 디스크의 로그 파일에 반영한다.
	- 커밋 시점에는 디스크에 `동기적`으로 반영하게 되는데 이 때 지연이 발생할 수 있다.
- 커밋을 자주 진행하면 `데이터의 정합성`은 **높아지지만** `성능`은 **낮아진다**.

## 시스템 특성에 따른 Trade-Off

### 데이터 캐시와 로그 버퍼의 크기

> 로그 버퍼 크기의 초기값은 왜 이렇게 작을까?
- 위와 같은 의문은 `성능` 때문이다.
- 갱신보다는 검색을 할 때 처리 대상이 많기 때문에 `검색`을 위해 데이터를 메모리에 올리는게 성능상으로 이점이 있다.
	- 따라서 초기 값으로 로그 버퍼의 크기가 작고, 데이터 캐시의 크기가 비교적 크다.
	- 물론 `갱신` 작업이 많은 서비스의 경우 `로그 버퍼`의 크기를 늘려 최적화를 고려할 수 있다.

- 정리
	- 갱신 처리가 많은 서비스 -> 로그 버퍼의 크기를 늘릴 수 있다.
	- 조회 처리가 많은 서비스 -> 데이터 캐시의 크기를 늘릴 수 있다. (기본 값으로 데이터 캐시가 훨씬 크다.)
	- 서비스의 특징을 고려하여 한정된 메모리를 어떻게 분배할지 고민해야 한다.

## 워킹 메모리란 뭘까?
### 언제 사용될까?
- 주로 정렬, 해시 관련 처리에 사용되는 영역이다.
	- 정렬은 `ORDER BY`, 집합 연산, 윈도우 함수 등에 사용
	- 해시는 테이블 결합에 사용
### 연산에 필요한 공간보다 워킹 메모리가 작으면 어떻게 처리할까?
- DBMS는 연산을 처리하기 위해 `저장소`(HDD)를 이용한다.
	- 저장소의 특정 공간을 임시 영역으로 부여받아 연산을 처리한다.
	- 해당 공간은 저장소 위에 있어 처리 속도가 **느리다**.

# 03 강 DBMS와 실행 계획
---

## 개발자는 SQL만 작성하면 된다?
- 개발자는 데이터가 어디에 존재하는지, 데이터에 어떻게 접근하는지 신경쓰지 않아도 된다.
- 그 이유는 DBMS가 해당 기능들을 제공해주기 때문이다.
- 하지만 DBMS의 처리 방식을 살펴보지 않으면 성능 문제로 고생할 수 있다.

## DBMS는 데이터를 접근하는 방식을 어떻게 결정할까?
- DBMS는 `쿼리 평가 엔진`을 통해 SQL 구문을 처리한다.

### 파서는 뭘까?
- 구문을 분석해 올바른 구문인지 보장해주는 역할을 수행한다.

### 옵티마이저는 뭘까?
- 실행 계획을 세우는 주체이다.
- 하는 일을 정리하면
	- 선택 가능한 여러 개의 `실행 계획 작성`
	- 각 실행 계획의 `비용 연산`

### 카탈로그 매니저는 뭘까?
- 옵티마이저가 실행 계획을 세우기 위해 필요한 정보를 제공해주는 주체이다.
> 카탈로그란? 
> DBMS의 내부 정보를 모아놓은 테이블들, 테이블 또는 인덱스의 통계 정보가 저장되어 있다.

### 플랜 평가는 뭘까?
- 실행 계획들을 받아 최적의 실행 결과를 선택하는 주체

![[Pasted image 20231010152023.png]]


## 옵티마이저는 만능일까?
- **아니다!** 통계 정보가 부족한 경우, 최적의 결과를 선택하지 않을 수 있다.
	- 카탈로그 정보(통계 정보)가 실제 테이블과 인덱스의 정보와 일치하지 않을 때

### 최적의 실행 계획을 작성하게 하려면 어떻게 해야할까?
- 테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야 한다.
- 통계 갱신 작업은 실행 비용이 높은 작업이므로 갱신 시점을 확실하게 검토해야 한다.


# 04 강 실행 계획이 SQL 구문의 성능을 결정
---

## 실행 계획은 어떻게 확인할까?

![[Pasted image 20231010161338.png]]

- 실행 SQL
``` SQL
EXPLAIN  
SELECT *  
FROM Photo
```

- 결과
![[스크린샷 2023-10-10 오후 4.18.30.png]]
- 위의 결과에서 3가지 열을 확인할 수 있다.
	1. 조작 대상 객체 (Photo)
	2. 객체에 대한 조작의 종류 (ALL)
	3. 조작 대상이 되는 레코드 수 (327)
		- 카탈로그 매니저를 통해 얻은 값이므로 실행한 시점의 테이블 상황과 다를 수 있다.

## 객체에 대한 조작의 종류에는 어떤게 있을까?
### 테이블 풀 스캔
- 해당 경우는 위의 과정에서 살펴보았다.
- 말 그대로 해당 테이블의 데이터를 모두 읽는다는 의미이다.

### 인덱스 스캔

- 실행 SQL
```SQL
EXPLAIN  
SELECT *  
FROM Photo  
WHERE photoIdx = 100;
```

- 결과
![[스크린샷 2023-10-10 오후 4.33.14.png]]
- WHERE 조건을 추가했더니 `type`열이 `const`로 변경되었다.
- 그리고 `possible_keys`열에는 `PRIMARY`로 되어있는 것을 발견할 수 있고, 레코드 수가 `1`인 것을 확인할 수 있다.
- 해당 결과는 인덱스를 이용하는 것을 나타내는데, 인덱스로 검색하면 검색되는 레코드 수가 적으면 일반적으로는 테이블 풀 스캔보다 **빠르다.**

## 테이블 결합에서의 실행 계획은 어떻게 될까?
- 테이블 결합의 경우 실행 계획이 매우 복잡하다.
- 이 때문에 옵티마이저도 최적의 실행 계획을 세우기 어려울 수 있다.
> 따라서 결합 시점의 실행 계획 특성을 공부해야 한다!!
- 테이블 결합 알고리즘에는 3가지가 존재한다.
	- Nested Loop
		- 중첩 반복을 통해 테이블을 결합하는 방식
	- Sort Merge
		- 결합 키로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방식
		- 정렬할 때 워킹 메모리 이용
	- Hash
		- 결합키 값을 해시값으로 매핑하는 방식
		- 해시 테이블을 위해 작업용 메모리 영역을 필요로 한다.


# 05 강 실행 계획의 중요성
---

## 옵티마이저가 만능은 아니다.
- 옵티마이저가 항상 최선의 실행 계획을 세우는 것은 아니다.
- 이에 따라 수동으로 실행 계획을 변경해야 할 때도 존재한다.
	- `힌트 구` 를 통해 강제적으로 명령할 수 있다.

> 개발자가 실행 계획을 변경해야 할 때도 있으므로 실행 계획을 꼭 공부해서 어떤 선택지가 있는지 알아야 한다!!

## 궁금한 점
---
### 로그 버퍼에서 커밋은 어떻게 진행될까?
### 데이터 캐시와 로그 버퍼의 크기를 정하기 위한 갱신과 조회의 비율은 어떻게 측정할까?
### MySQL은 카탈로그를 어떻게 관리하고, 실행 계획은 어떻게 보여줄까?


## 피드백
---
- 단순히 책 내용을 공유하다보니 얘기할 거리가 부족한 느낌이다.
- 이번 파트의 경우에는 너무 개략적인 내용이라 할 얘기가 없는 것 같다.
- 둘째날에 어떤 것을 해야 할지 모르겠다.
