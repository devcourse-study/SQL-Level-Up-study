# DBMS 아키텍처

[1. DBMS 아키텍처 개요](#1-dbms-아키텍처-개요)

[2. DBMS와 버퍼](#2-DBMS와-버퍼)

[3. DBMS와 실행 계획](#3-DBMS와-실행-계획)

[4. 실행 계획이 SQL 구문의 성능을 결정](#4-실행-계획이-SQL-구문의-성능을-결정)

[5. 실행 계획의 중요성](#5-실행-계획의-중요성)

## 1. DBMS 아키텍처 개요

사진 첨부

### 1-1. 쿼리 평가 엔진

- 플랜 실행 기능, 연산 평가 기능을 가지고 있고, 파서와 옵티마이저로 구성되어 있습니다.
- **사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정하는 역할을 합니다.**
- 성능과도 깊은 관련이 있는 모듈입니다.

### 1-2. 버퍼 매니저

- **버퍼라는 메모리 영역을 관리하는 역할을 합니다.**
- 디스크 용량 매니저와 함께 연동되어 작동합니다.

### 1-3. 디스크 용량 매니저

- 어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어합니다.

### 1-4. 트랜잭션 매니저와 락 매니저

- 여러 사람이 동시에 데이터베이스를 접근해 사용하기 위해 트랜잭션이라는 단위로 DBMS의 동작을 관리하는데, 이 트랜잭션의 정합성을 유지하면서 실행시키는 역할을 합니다.
- 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 역할을 합니다.

### 1-5. 리커버리 매니저

- 시스템의 장애를 대비하여 데이터를 정기적으로 백업하고, 문제 발생 시 복구해주는 기능을 수행합니다.  

> 이 책에서는 ‘하나의 구문을 실행하는 때’의 성능과 관련한 내용들을 짚어봅니다. 이와 관련된 것들은 ‘쿼리 평가 엔진’, 혹은 ‘실행 계획’입니다. ‘버퍼 매니저’ 또한 성능과 밀접한 관련이 있습니다.

<br/>

## 2. DBMS와 버퍼

버퍼는 성능에 굉장히 중요한 영향을 미칩니다. 메모리의 용량은 한정되어있지만 데이터베이스가 메모리에 저장하고자 하는 데이터는 굉장히 많기 때문에, 데이터를 버퍼에 어떤 식으로 확보할 것인가 하는 부분에서 트레이드오프가 발생합니다.

### 2-1. 공짜 밥은 존재할까?

기억장치는 그 종류(메모리, HDD 등)에 따라 저장 가능한 용량과 접근 속도 사이에 트레이드오프가 존재합니다. 

### 2-2. DBMS와 기억장치의 관계

DBMS가 사용하는 대표적인 기억장치는 다음과 같은 2가지입니다.

- 하드디스크(HDD)
    - DBMS가 데이터를 저장하는 대표적인 매체입니다.
    - 어떤 상황(또는 관점)에서도 평균적인 수치를 가지는 매체이기 때문에 범용적으로 사용되는 DBMS에 적절합니다.
- 메모리
    - DBMS는 항상 디스크에만 데이터를 저장하지 않습니다. 디스크 이외의 저장소에도 데이터를 올려놓는데, 그것이 메모리입니다.
    - 메모리의 용량은 아무리 커도 100GB를 잘 넘지 않기 때문에, 모든 데이터를 메모리에 올려놓는 것은 불가능합니다.
- 버퍼를 활용한 속도 향상
    - 그럼에도 메모리(버퍼)에 데이터를 올려놓는 이유는 성능 향상 때문입니다. SQL 구문의 실행 속도를 빠르게 만들기 위함입니다.
    - 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도 디스크에 접근할 필요 없이 곧바로 메모리에서 빠르게 읽을 수 있습니다.
    - 성능 향상의 목적으로 데이터를 저장하는 메모리를 버퍼 또는 캐시라고 합니다.
    - **버퍼 매니저는 버퍼에 데이터를 어떻게, 어느 정도의 기간 동안 올릴지를 관리하는 역할을 함**
    
### 2-3. 메모리 위에 있는 두 개의 버퍼

- 데이터 캐시: 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역입니다.
- 로그 버퍼: 갱신 처리와 관련 있는 버퍼입니다.
    - DBMS는 갱신과 관련된 SQL 구문을 받으면 곧바로 저장소에 반영하지 않습니다. 일단 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 시도합니다. 즉, 갱신 처리는 비동기로 이루어집니다.
    - 비동기로 이루어지는 이유: 데이터 갱신 또한 시간이 많이 쓰이는 작업이기 때문에, 저장소 변경이 끝날때까지 기다리게 되면 응답성이 떨어지게 됩니다. 이 때문에 비동기로 갱신 작업을 처리합니다. 
    - 따라서 로그 버퍼에 갱신 정보를 받은 시점에서 SQL 구문에게 '끝났다' 라고 통보하고, 내부적으로는 디스크에 갱신 정보를 반영하는 처리를 계속 수행하는 것입니다.

#### MySQL의 메모리 크기 및 설정, 명칭

- 데이터 캐시
    - 명칭: 버퍼 풀
    - 매개변수: innnodb_buffer_pool_size
    - 초기값: 128MB
    - 설정값 확인 명령어 예: `SHOW VARIABLES LIKE 'innodb_buffer_pool_size';`
- 로그 버퍼
    - 명칭: 로그 버퍼
    - 매개변수: innnodb_log_buffer_size
    - 초기값: 8MB
    - 설정값 확인 명령어 예: `SHOW VARIABLES LIKE 'innnodb_log_buffer_size';`

### 2-4. 메모리의 성질이 초래하는 트레이드오프

#### 휘발성

메모리의 데이터에는 영속성이 없습니다. 그렇기 떄문에 시스템에 장애가 발생해서 프로세스 다운이 일어나면 메모리에 올라가있는 버퍼 정보가 다 삭제됩니다.

#### 휘발성의 문제점

메모리의 데이터가 모두 휘발되면 데이터 부정합이 발생합니다. 데이터 캐시의 경우 조회 속도를 위한 버퍼이므로 문제가 없습니다. 
하지만 로그 버퍼의 경우, 만약 로그 버퍼의 데이터가 디스크 위의 로그 파일에 반영되기 전에 장애가 발생한다면? 사용자가 수행했던 갱신 정보가 사라진다는 것을 의미합니다.  

이를 방지하기 위해 DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일(영속적인 저장소에 위치)에 씀으로써, 장애가 발생해도 정합성을 유지할 수 있게 합니다. 이럴 경우 커밋 때는 반드시 디스크에 동기 접근이 일어나고, 지연이 발생할 가능성이 있습니다.
바로 여기에서 트레이드오프가 발생합니다.  

**데이터 정합성(동기) ←→ 실행 속도(비동기)**

### 2-5. 시스템 특성에 따른 트레이드오프

DBMS는 초기값으로 데이터 캐시의 용량에 비해 로그 버퍼의 용량을 극단적으로 작게 설정하는 것을 알 수 있었습니다. 그 이유는 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문입니다.

많은 데이터베이스가 데이터 캐시를 되도록 많이 할당할 것을 추천하고 있습니다.(MySQL의 경우 서버가 데이터베이스 전용이라면 물리 메모리의 80%를 버퍼 풀로 할당해도 괜찮다고 설명. 5.7버전 기준)  

중요한 것은 서비스의 특성(검색과 갱신의 비중)에 따라 버퍼들의 크기를 튜닝하는 것을 고려해야 한다는 점입니다.
요즘의 DBMS는 자동으로 메모리 할당을 조정하는 기술이 있지만, 굉장히 중요한 리소스 배분이 필요한 상황에서 아무 생각 없이 자동 설정에 의존해서는 안됩니다. 검색과 갱신 중에서 어떤 것이 우선되어야 하는지 그 트레이드오프를 따져봐야 합니다.

### 2-6. 추가적인 메모리 영역 ‘워킹 메모리’

앞서 설명한 두 가지 메모리 말고 일반적으로 하나의 메모리를 더 사용하는데, 바로 워킹 메모리입니다. 워킹 메모리는 정렬 또는 해시 관련 처리에 이용됩니다.

- 정렬: ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능에 사용됨
- 해시: 테이블 등의 결합에서 해시 결합이 사용됨. GROUP BY에서도 해시 알고리즘이 사용되는 경우가 있음

#### MySQL의 워킹 메모리 설정

- 명칭: 정렬 버퍼
- 매개변수: sort_buffer_size
- 기본값: 256KB

워킹 메모리는 사용이 완료되면 바로 해제되는 임시 영역입니다. 이 영역이 중요한 이유는 다루려는 데이더보다 이 영역이 더 작으면 디스크를 사용하기 때문입니다(OS의 swap과 같은 것).  

디스크를 사용하므로 성능이 저하되고, 이 영역은 여러 SQL 구문들이 공유해서 사용하므로 여러개의 구문을 실행했을 때 그 성능이 떨어지는 경우가 있습니다.
그러한 상황을 재현하는 검사(부하 테스트)를 실시해서 파악해야 합니다.

<br/>

## 3. DBMS와 실행 계획

### 3-1. 권한 이양의 죄악

DBMS는 프로그래밍 언어인 C++, Java와 다르게 데이터에 어떻게 접근하는지 절차적인 세부사항이 SQL에 드러나지 않습니다. 
SQL 구문을 읽어 데이터를 찾고 결과를 제공해주는 일은 모두 DBMS가 처리합니다.  

이러한 특징은 개발자로 하여금 비즈니스 개발의 생산성을 높여주지만, How를 의식하지 않고 사용하는 것 때문에 성능 문제로 고생하는 경우도 꽤 있습니다. 
RDB가 숨기고 있는 내부 절차를 들여다봐야 하는 것은 이러한 이유 때문입니다.

### 3-2. 데이터에 접근하는 방법은 어떻게 결정할까?

사진 첨부

데이터 접근 절차를 결정하는 모듈은 쿼리 평가 엔진입니다. 쿼리 평가 엔진은 추가로 파서와 옵티마이저와 같은 여러개의 서브 모듈로 구성됩니다.

#### 데이터 접근 방법이 결정되는 과정
1. **파서**가 사용자로부터 입력받은 SQL이 구문적으로 올바른지 검증해주고, SQL을 정형적인 형식으로 변환
2. **옵티마이저**가 파스된 쿼리를 받아 실행 계획을 작성. 이때 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서, 선택 가능한 많은 실행 계획을 작성하고, 이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택
    1. **카탈로그 매니저**는 옵티마이저가 실행 계획을 세울 때 중요한 정보를 제공해줌. **카탈로그**란 DBMS의 내부 정보를 의미하고, 테이블 또는 인덱스의 통계 정보가 저장되어 있음.
3. 최종적으로 선택된 실행 계획을 DBMS가 절차적인 코드로 변환하고 데이터 접근을 수행

### 3-3. 옵티마이저와 통계 정보

개발자가 중요하 생각해야 할 것은 옵티마이저를 잘 사용하는 것입니다. 특히 카탈로그 매니저가 관리하는 통계 정보에 대해서는 항상 신경써줘야 합니다. 실제로 옵티마이저가 최적의 실행 계획을 선택하지 못하는 경우도 있고, 그 대표적인 원인으로는 통계 정보가 부족상 경우입니다.

#### 카탈로그에 포함되어있는 통계 정보
- 각 테이블 레코드 수
- 각 테이블의 필드 수와 필드의 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(어떤 값이 얼마나 분포해있나)
- 필드 내부에 있는 NULL 수
- 인덱스 정보

문제는 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때 입니다. 데이터 갱신이 일어날 때 카탈로그 정보가 갱신되지 않으면 옵티마이저는 과거의 통계 정보만 가지고 실행 계획을 세우기 때문에 어쩔 수 없이 잘못된 계획을 세울 수 밖에 없습니다.  

극단적인 예로 0개의 row를 갖는 테이블 생성 후 카탈로그가 저장됩니다. 이후 1억 건의 데이터를 저장하고 카탈로그를 갱신하지 않는다면 옵티마이저는 데이터 0개를 기준으로 플랜을 생성하게 됩니다.

### 3-4. 최적의 실행 계획이 작성되게 하려면

적절한 시점에 카탈로그를 갱신하여 실행 계획이 올바르게 작성되게 하는 것은 필수입니다. 수동으로 직접 생성하거나, 특정 이벤트(배치 처리, 데이터 갱신 등) 발생 시 자동으로 갱신 작업이 수행되는 경우도 있고, 이는 DBMS마다 다릅니다.   

사실 카탈로그 갱신 작업은 대상 테이블 또는 인덱스의 크기와 수에 따라서 몇십 분에서 몇 시간 정도 소요되는, 실행 비용이 굉장히 높은 작업입니다. 하지만 이 작업은 옵티마이저가 최적의 실행 계획을 세우게 하기 위한 필수적인 요소입니다.

- MySQL의 통계 정보 갱신 명령어: `ANALYZE TABLE [스키마 이름].[테이블 이름];`

<br/>

## 4. 실행 계획이 SQL 구문의 성능을 결정

앞선 내용처럼 통계 정보가 부족해도 구문 실행 반응 지연이 발생하지만, 이미 최적의 접근 경로가 세워져있는데도 느린 경우가 있습니다. 또한 통계 정보가 최신이라도 SQL 구문이 너무 복잡하면 옵티마이저가 최적의 접근 경로를 선택하지 못할 수도 있습니다.

### 4-1. 실행 계획 확인 방법

SQL 지연이 발생했을 땐 우선 실행 계획을 살펴봐야 합니다.

- MySQL의 실행 계획 확인 명령어: `EXPLAIN [SQL 구문]`

### 4-2. 테이블 풀 스캔의 실행 계획

<img width="1303" alt="스크린샷 2023-10-13 오후 5 09 25" src="https://github.com/devcourse-study/SQL-Level-Up-study/assets/35731532/5f3bca49-e6d1-4528-a0e4-00dd4ebfc99d">

#### DBMS가 실행 계획에 포함하는 내용
1. 조작 대상 객체(테이블, 인덱스, 파티션, 시퀀스 등등이 객체가 됨)
2. 객체에 대한 조작의 종류
3. 조작 대상이 되는 레코드 수

> 실행 계획의 비용과 시간은 맹신하면 안됩니다. 비용은 절대 평가의 지표로 쓰는 것은 추측에 그치기 때문에 위험합니다. 실행 시간은 경우에 따라 다르지만, 추정되는 시간일 경우 실제 시간과 차이가 있을 수 있습니다.

### 4-3. 인덱스 스캔의 실행 계획

<img width="1302" alt="스크린샷 2023-10-13 오후 5 10 29" src="https://github.com/devcourse-study/SQL-Level-Up-study/assets/35731532/5db24a93-86c8-452e-901c-52d5dc4cda6a">

- 조작 대상이 되는 레코드 수가 1로 변함(PK는 유니크)
- 접근 대상 객체와 조작: 인덱스를 사용한 스캔

### 4-4. 간단한 테이블 결합(JOIN)의 실행 계획

<img width="1256" alt="스크린샷 2023-10-13 오후 5 12 46" src="https://github.com/devcourse-study/SQL-Level-Up-study/assets/35731532/d0079198-057c-4e56-a720-d36b163639fd">

결합을 사용하면 실행 계획이 상당히 복잡해지므로, 옵티마이저도 최적의 실행 계획을 세우기 어렵습니다. 따라서 결합 시점의 실행 계획 특성을 공부하는 것은 굉장히 중요한 의미가 있습니다.  

#### DBMS가 결합에 사용하는 알고리즘
1. Nested Loops: 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식(2중 for문의 형태)
2. Sort Merge: 결합 키로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방법. 결합 전에 정렬을 수행하기 때문에 워킹 메모리를 사용
3. Hash: 결합 키값을 해시값으로 매핑하는 방법. 마찬가지로 워킹 메모리를 사용

복잡한 실행 계획을 읽는 방법에 대해 설명하면, 실행 계획은 기본적으로 트리 구조고, 중첩 단계가 깊을수록 먼저 실행됩니다. 같은 중첩 단계에서는 위에서 아래로 실행합니다.

<br/>

## 5. 실행 계획의 중요성

옵티마이저는 꽤 우수하지만 완벽하지 않습니다. 예를 들면 인덱스를 사용해야 빨라지는 부분인데 사용하지 않거나, 테이블 결합 순서를 이상하게 적는 실수를 할 수도 있습니다. 이럴 경우 최후의 튜닝 수단을 사용해야 합니다. 바로 실행 계획을 수동으로 변경해주는 것입니다. MySQL의 경우 힌트 구를 사용하면 SQL 구문에서 옵티마이저에게 강제적으로 명령할 수 있습니다.  

이렇게 실행 계획을 변경하려면 어떤 선택지가 있는지를 알아야 합니다. 어떤 기능에 대해 어떤 선택지들이 있는지 알아봐야 합니다. 그 전에, SQL 구문과 그러한 SQL 구문들이 어떠한 접근 경로로 데이터를 검색하는지 아는지가 먼저입니다. 그리고 제대로 된 SQL 구문을 작성하려면 어떤 테이블 설정이 효율적인지 알아야 하며, 어떤 SQL 구문이 주어졌을 때 어떤 실행 계획이 나올지 예측할 수도 있어야 합니다.

## 추가로 공부한 내용 및 레퍼런스

### MySQL의 버퍼 풀
https://yelimkim98.tistory.com/55

### 실무에서는 검색과 갱신의 비율을 어떻게 판단할까?

- 데이터베이스 성능 모니터링
https://www.whatap.io/ko/blog/159/

- 로그 및 SQL 진입점 정보 추가 여정
https://techblog.woowahan.com/13429/
