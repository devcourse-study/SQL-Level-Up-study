# 1. 기능적 관점으로 구분하는 결합의 종류

SQL에는 ‘결합’이라고 하는 이름이 붙은 연산이 굉장히 많습니다.

- 크로스 결합
- 내부 결합
- 외부 결합
- 자기 결합
- 등가 결합/비등가 결합
- 자연 결합

이들 중 기능적인 관점으로 분류하는 것이 크로스 결합, 내부 결합, 외부 결합입니다. 등가 결합/비등가 결합은 결합 조건으로 등호를 사용하는지, 부등호를 사용하는지의 차이를 의미합니다.

## 1-1. 크로스 결합 - 모든 결합의 모체

크로스 결합은 실무에서 거의 사용할 기회가 거의 없습니다. 그럼에도 크로스 결합을 살펴보는 이유는 크로스 결합이라는 연산을 이해하는 지름길이기 때문입니다.

### 크로스 결합의 작동

크로스 결합을 이해하기 위한 사원 테이블과 부서 테이블을 살펴보겠습니다.

| emp_id(사원 ID) | emp_name(사원 이름) | dept_id(부서 ID) |
| --- | --- | --- |
| 001 | 하린 | 10 |
| 002 | 한미루 | 11 |
| 003 | 사라 | 11 |
| 004 | 중민 | 12 |
| 005 | 웅식 | 12 |
| 006 | 주아 | 12 |

| dept_id(부서 ID) | depet_name(부서 이름) |
| --- | --- |
| 10 | 총무 |
| 11 | 인사 |
| 12 | 개발 |
| 13 | 영업 |

```sql
CREATE TABLE Employees
(emp_id CHAR(8),
emp_name VARCHAR(32),
dept_id CHAR(2),
CONSTRAINT pk_emp PRIMARY KEY(emp_id));

CREATE TABLE Departments
(dept_id CHAR(2),
dept_name VARCHAR(32),
CONSTRAINT pk_dep PRIMARY KEY(dept_id));
```

이 두 개의 테이블에 크로스 결합을 적용하는 구문을 작성해보겠습니다.

```sql
SELECT *
FROM Employees
CROSS JOIN Departments;
```

크로스 결합은 2개 테이블의 레코드에서 가능한 모든 조합을 구하는 연산입니다. 그러므로 크로스 결합의 결과 레코드 수는 회사 테이블의 레코드 수 6개와 부서 테이블의 레코드 수 4개를 곱하는 24개가 됩니다.

### 크로스 결합이 사용되지 않는 이유

크로스 결합이 실무에서 사용되지 않는 이유는 다음과 같은 두 가지입니다.

- 이러한 결과가 필요한 경우가 없다.
- 비용이 매우 많이 드는 연산이다.

### 실수로 사용한 크로스 결합

실무에서 크로스 결합이 발생하는 흔한 경우는 다음과 같이 실수로 결합 조건을 적지 않았을 때입니다.

```sql
SELECT *
FROM Employees, Departments;
```

이러한 실수를 막으려면 표준 SQL에 맞게 결합 구문을 사용하는 것이 좋습니다.

## 1-2. 내부 결합 - 왜 ‘내부’라는 말을 사용할까?

### 내부 결합의 작동

현재 사원 테이블만으로는 사원의 부서 이름을 알 수 없습니다. 부서 이름을 알려면 부서 테이블의 부서 이름 필드에 있는 정보를 가져와야 합니다. 따라서 양쪽 테이블 모두에 존재하는 부서 ID 필드를 사용합니다.

```sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
FROM Employees E INNER JOIN Departments D
ON E.dept_id = D.dept_id;

//실행 결과
emp_id | emp_name | dept_id | dept_name
----------------------------------------
001    | 하린      | 10      | 총무
002    | 한미루     | 11      | 인사
003    | 사라      | 11      | 인사
004    | 중민      | 12      | 개발
005    | 웅식      | 12      | 개발
006    | 주아      | 12      | 개발
```

결과를 보면 알 수 있듯이, 내부 결합의 결과는 모두 크로스 결합 결과의 일부(부분 집합)라는 것을 알 수 있습니다. 이것이 내부 결합에서 내부라는 용어를 사용하는 이유입니다.

### 내부 결합과 같은 기능을 하는 상관 서브쿼리

내부 결합은 기능적으로 상관 서브쿼리를 사용해 대체 가능한 경우가 많습니다. 예를 들어 위의 내부 결합 쿼리를 상관 서브쿼리로 만든다면 아래와 같습니다.

```sql
SELECT E.emp_id, E.emp_name, E.dept_id,
			(SELECT D.dept_name
				FROM Departments D
				WHERE E.dept_id = D.dept_id) AS dept_name
FROM Employees E;
```

emp_id, emp_name, dept_id는 평범하게 사원 테이블에서 선택합니다. 중요한 부분은 부서 이름을 선택하는 마지막 줄입니다. dept_id는 부서 테이블의 기본 키이므로, 이를 조건으로 지정하면 레코드가 한 개로 한정될 것이 보장됩니다. 따라서 기본 키를 사용하면 상관 서브쿼리를 스칼라 서브쿼리로 사용할 수 있습니다. 스칼라 서브쿼리는 리턴값이 하나의 단일값인 쿼리입니다. 이러한 성질로 SELECT 구문에서 사용할 수 있습니다.

성능을 비교하면 기본적으로 결합을 사용하는 것이 좋습니다. 상관 서브쿼리는 결과 레코드 수만큼 상관 서브쿼리를 실행해 비용이 꽤 높아집니다.

## 1-3. 외부 결합 - 왜 ‘외부’라는 말을 사용할까?

‘내부’와 ‘외부’라는 명칭이 나타내는 것처럼 내부 결합과 외부 결합은 배타적인 연산입니다.

### 외부 결합의 작동

외부 결합은 다음과 같이 세 가지 종류가 있습니다.

- 왼쪽 외부 결합
- 오른쪽 외부 결합
- 완전 외부 결합

여기에서 왼쪽 외부 결합과 오른쪽 외부 결합은 마스터가 되는 테이블을 어느 쪽에 작성할지만 다를 뿐, 실질적으로 같은 기능을 가집니다.

```sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
FROM Departments D LEFT OUTER JOIN Employees E
ON D.dept_id = E.dept_id;

SELECT E.emp_id, E.emp_name, D.dept_id, D.dept_name
FROM Employees E RIGHT OUTER JOIN Departments D
ON E.dept_id = D.dept_id;

//실행 결과
emp_id | emp_name | dept_id | dept_name
----------------------------------------
001    | 하린      | 10      | 총무
002    | 한미루     | 11      | 인사
003    | 사라      | 11      | 인사
004    | 중민      | 12      | 개발
005    | 웅식      | 12      | 개발
006    | 주아      | 12      | 개발
NULL   | NULL     | 13      | 영입
```

실행 결과의 마지막 레코드를 보면 알 수 있듯이, 마스터 테이블 쪽에만 존재하는 키가 있을 때는 해당 키를 제거하지 않고 결과에 보존합니다. 따라서 키를 모두 가진 레이아웃의 리포트를 만들 때 자주 사용합니다.

## 1-4. 외부 결합과 내부 결합의 차이

외부 결합에서 ‘외부’의 의미는 위 실행 결과에서 알 수 있듯이 크로스 결합 결과의 부분집합이 아니라는 뜻입니다. 크로스 결합 결과의 부분집합이 아닌 이유는 외부 결합이 마스터 테이블의 정보를 모두 보존하고자 NULL을 생성하기 때문입니다.

## 1-5. 자기 결합 - ‘자기’란 누구일까?

자기 결합(self join)은 문자 그대로 자기 자신과 결합하는 연산으로, 간단하게 말하면 같은 테이블(또는 같은 뷰)를 사용해 결합하는 것입니다. 자기 결합은 크로스, 내부, 외부 결합처럼 생성되는 결과를 기준으로 분류하는 것이 아니라 연산의 대상을 무엇으로 사용하는지에 따른 분류입니다. 때문에 ‘자기 결합 + 내부 결합’과 같은 조합이 가능합니다.

### 자기 결합의 작동

아래처럼 한 개의 레코드행이 하나의 숫자를 가지는 숫자 테이블을 준비합니다. 이 테이블에 ‘자기 결합 + 크로스 결합’을 해보겠습니다.

| digit(숫자) |
| --- |
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

```sql
SELECT D1.digit + (D2.digit * 10) AS seq
FROM Digits D1 CROSS JOIN Digits D2;

//실행 결과
0
1
2
...생략
97
98
99
```

### 자기 결합의 사고방식

자기 결합을 수행하는 경우는 일반적으로 같은 테이블에 별칭(현재 코드에서는 D1 D2)를 붙여 마치 다른 테이블인 것처럼 다룹니다. 쿼리의 작동을 파악하기 위한 것만이라면 완전히 다른 테이블로 분리해서 생각해도 상관없습니다. 따라서 D1과 D2를 우연하게 같은 데이터를 저장하고 있는 두 개의 서로 다른 테이블이라고 보면 좋습니다.

# 2. 결합 알고리즘과 성능

지금부터는 SQL에서 결합 연산을 수행할 때 내부적으로 선택되는 알고리즘을 바탕으로 결합에 대해 알아보겠습니다.

옵티마이저가 선택 가능한 결합 알고리즘은 크게 다음과 같은 세 가지가 있습니다.

- Nested Loops
- Hash
- Sort Merged(위 두 알고리즘에 비해 중요도가 떨어짐)

어떤 DBMS의 어떤 버전을 쓰느냐에 따라 사용하는 알고리즘이 다르므로 항상 최신 동향을 살펴야 합니다.

> MySQL의 결합 알고리즘
> 

## 2-1. Nested Loops

### Nested Loops의 작동

Nested Loops는 이름 그대로 중첩 반복을 사용하는 알고리즘입니다. SQL에서 결합은 한 번에 두 개의 테이블만 결합하므로 이중 반복과 같은 의미입니다.

세부 규칙은 다음과 같습니다.

1. 결합 대상 테이블에서 레코드를 하나씩 반복해가며 스캔합니다. 이 테이블을 구동 테이블(driven table) 또는 외부 테이블(outer table)이라고 합니다. 다른 테이블은 내부 테이블(inner table)이라고 부릅니다.
2. 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴합니다.
3. 구동 테이블의 모든 레코드에 대해 반복합니다.

이러한 Nested Loops는 다음과 같은 특징이 있습니다.

- Nested Loops이 접근하는 레코드 수는 테이블들의 레코드 수의 곱이다. 즉, Nested Loops의 실행 시간은 접근하는 레코드 수에 비례한다.
- 한 번에 처리하는 레코드 수가 적으므로 Hash 또는 Sort Merge에 비해 메모리 소비가 적다(왜?)
- 모든 DBMS에서 지원한다

원리는 단순하지만 결합 성능에서 가장 중요한 것이라고 해도 과언이 아닌 중요한 알고리즘입니다. 특히 어떤 테이블이 구동 테이블로 사용할지가 큰 요인이 됩니다. 

어떤 테이블이 구동 테이블이 되던 접근하는 레코드 수 자체는 변하지 않지만, 구동 테이블이 작을수록 Nested Loops의 성능이 좋아집니다. 여기서 중요한 것은 이중 반복의 외측과 내측의 반복 처리가 비대칭이라는 점입니다.

(정확히는 검색 조건으로 압축된 구동 테이블의 레코드 수가 작을 때입니다.)

### 구동 테이블의 중요성

Nested Loops의  성능을 개선하는 키워드가 ‘구동 테이블로는 작은 테이블을 선택하는 것’이라고 하지만, 더 정확히 왜 구동 테이블이 작을수록 성능이 좋을까, 이것이 의미를 가지는 조건은 무엇일까, 그 이유는 무엇일까를 차근차근 알아봅시다.

실제로 접근하는 레코드 수는 어떤 테이블을 구동 테이블로 선택하던 변하지 않지만, ‘구동 테이블을 작게’라는 말에는 다음 전제가 포함됩니다.

> 내부 테이블의 결합 키 필드에 인덱스가 존재
> 

만약 내부 테이블의 결합 키 필드에 인덱스가 존재한다면, 내부 테이블을 완전히 순환하지 않아도 됩니다. 달리 말하면 내부 테이블의 반복을 어느 정도 건너뛸 수 있게 됩니다.

이상적인 경우는 구동 테이블의 레코드 한 개에 내부 테이블의 레코드 한 개가 대응하고, 해당 레코드를 내부 테이블의 인덱스를 사용해 반복없이 찾을 수 있는 경우입니다. 이렇게 되면 반복을 생략할 수 있어 접근하는 레코드 수는 (구동 테이블 레코드 수) * 2가 됩니다. 

```sql
SELECT E.emp_id, E.emp_name, E.dept_id, D.dept_name
FROM Employees INNER JOIN Departments D
ON E.dept_id = D.dept_id;
```

이때 그림처럼 내부 테이블의 결합 키 인덱스(department_pkey, PK_DEP)가 사용된다면 내부 테이블의 반복을 생략할 수 있으므로 Nested Loops가 빨라집니다.

(캡쳐)

하지만 그림처럼 내부 테이블의 결합 키 인덱스가 사용되지 않으면 구동 테이블이 작아봤자 아무런 장점이 없습니다.

(캡쳐)

내부 테이블의 반복을 완전히 생략할 수 있는 경우는 결합 키가 내부 테이블에 대해 유일한 경우 뿐입니다. 그런 경우 Oracle 기준으로 ‘INDEX UNIQUE SCAN’을 실행합니다. 이 경우 굉장히 효율적으로 접근할 수 있습니다. 그렇지 않으면 Oracle 기준으로 ‘INDEX RANGE SCAN’을 실행합니다. 결합 키에 대해 레코드가 여러 개 히트될 수 있으므로 여러 개 레코드에 대한 반복을 수행해야 합니다.

‘구동 테이블이 작은 Nested Loops’ + ‘내부 테이블의 결합 키에 인덱스’라는 조합은 SQL 튜닝의 기본입니다.

### Nested Loops의 단점

위의 조건을 만족해도 기대한만큼의 응답 시간이 나오지 않는 경우도 있습니다. 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 너무 많은 경우인데, 이는 앞에서 설명했던 ‘결합 키가 내부 테이블에 대해 유일하지 않은 경우’에 발생할 수 있습니다. 인덱스로 반복을 생략할 수 있다 해도, 결국 절대적인 양이 너무 많아 지연이 일어나는 것입니다.

예를 들어 점포 테이블과 점포에서 받은 주문 테이블을 생각해봅시다. 이 경우 하나의 점포에 대해 여러 개의 주문이 대응되므로 점포 테이블을 구동 테이블로 만들고 점포 ID를 결합 키로 사용하는 것을 생각할 수 있습니다. 하지만 인기있는 점포의 경우 대응되는 주문 레코드가 너무 많아 Nested Loops의 성능이 낮아집니다. 이렇게 SQL의 구조가 같음에도 외부에서 받는 검색 매개변수(점포 ID)에 따라 성능이 균등하지 않게 나옵니다. SQL의 성능은 처하는 데이터 양에 의존하기 때문입니다.

이를 해결하는 방법은 두 가지입니다. 첫 번째는 구동 테이블로 큰 테이블을 선택하는 역설적인 방법입니다. 내부 테이블에 대한 접근이 기본 키(점포 ID)로 수행되므로, 항상 하나의 레코드에 접근하는 것이 보장됩니다. 따라서 성능 비균등 문제를 해결하면서, 극단적으로 성능이 저하되는 것을 막을 수 있습니다. 두 번쩨 방법은 뒤이어 설명할 해시입니다.

## 2-2. Hash

Hash 결합은 일단 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해 해시값으로 반환합니다. 이어서 다른 테이블(큰 테이블)을 스캔하고, 결합 키가 해시값에 존재하는지를 확인하는 방법으로 결합을 수행합니다.

작은 테이블에서 해시 테이블을 만드는 이유는, 해시 테이블이 워킹 메모리에 저장되므로 조금이라도 작은 것이 효율적이기 때문입니다. 또한 Hash가 사용되는 경우 어느 한 쪽의 테이블이 극단적으로 작거나 크지 않습니다. 한 쪽 테이블이 극단적으로 작은 경우라면 Nested Loops가 좋습니다.(왜?)

실행 계획을 통해 Hash의 동작 방식을 확인할 수 있습니다. 먼저 읽어들인 테이블의 부서 ID로 해시 테이블을 만들고, 이어서 다른 테이블을 읽어들여 해시값이 일치하는지 확인합니다.

(사진)

### Hash의 특징

- 결합 테이블로부터 해시 테이블을 만들기 때문에, Nested Loops에 비해 메모리를 크게 소모한다
- 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다
- 출력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에만 사용할 수 있다

### Hash가 유용한 경우

- Nested Loops에서 적절한 구동 테이블(상대적으로 충분히 작은 테이블)이 존재하지 않는 경우
- 앞서 ‘Nested Loops의 단점’에서 본 것처럼 구동 테이블로 사용할만한 작은 테이블은 있지만, 내부 테이블에서 히트되는 레코드 수가 너무 많은 경우
- Nested Loops의 내부 테이블에 인덱스가 존재하지 않는(또는 여러 가지 사정에 의해 인덱스를 추가할 수 없는) 경우

한마디로 Nested Loops가 효율적이지 않은 경우의 차선책이 Hash입니다.

다만 Hash에도 주의해야 할 트레이드오프가 있습니다. 첫 번째는 초기에 해시 테이블을 만들어야 하므로, Nested Loops에 비해 소비하는 메모리 양이 많다는 것입니다. 동시 실행성이 높은 웹 애플리케이션 처리를 할 때 Hash가 사용되면 메모리가 부족해져 저장소기 사용됩니다. 반대로 동시 처리가 적은 야간 배치 처리 등과 같은 시스템에 한해 사용하는 것이 Hash를 사용하는 기본 전략입니다.

두번째 트레이드오프로는 Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 읽어야 하므로, 테이블 풀 스캔이 사용되는 경우가 많습니다. 따라서 테이블 규모가 굉장히 크다면, 이런 풀 스캔에 걸리는 시간도 고려해야 합니다.

## 2-3. Sort Merge

### Sort Merge의 작동(Merge Sort 알고리즘과 전혀 다름)

Nested Loops가 비효율적인 경우, Hash 외에 또 다른 선택지로 Sort Merge라는 알고리즘이 있습니다. Sort Merge는 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합합니다.

### Sort Merge의 특징

1. 대상 테이블을 모두 졍렬해야 하므로 Nested Loops보다 많은 메모리를 소비합니다. 메모리 부족으로 I/O 비용이 늘어나고 지연이 발생할 위험이 있습니다.
2. Hash와 다르게 동치 결합뿐만 아니라 부등호(<, >, ≤, ≥)를 사용한 결합에도 사용할 수 있습니다.
3. 원리적으로는 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있습니다. 하지만 이러한 생략은 DBMS의 구현 의존적입니다.
4. 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에 결합을 완료할 수 있습니다.

### Sort Merge가 유효한 경우

Sort Merge 결합 자체에 걸리는 시간은 나쁘지 않은 편이지만, 정렬에 많은 리소스를 요구할 가능성이 있습니다. 따라서 정렬을 생략할 수 있는 (상당히 예외적인) 경우에는 고려해볼 만하지만, 그 이외의 경우에는 Nested Loops와 Hash를 우선적으로 고려합니다.

## 2-4. 의도하지 않은 크로스 결합

크로스 결합은 앞에서도 말했듯이 실무에서 사용할 일은 거의 없습니다. 결합 조건이 없는 결합을 사용할 기회가 거의 없기 때문입니다. 하지만 의도하지 않게 크로스 결합이 나타나는 경우가 있는데, 바로 ‘삼각 결합’이라고 부르는 패턴입니다. 예를 들어 다음과 같은 쿼리의 경우 발생합니다.

```sql
SELECT A.col_a, B.col_b, C.col_c
FROM Table_A A
INNER JOIN Table_B B
ON A.col_a = B.col_b
INNER JOIN Table_C C
ON A.col_ = C.col_c;
```

이 쿼리의 특징은 결합 조건이 ‘Table_A - Table_B’와 ‘Table_A - Table_C’에만 존재하고, ‘Table_B - Table_C’에는 결합 조건이 존재하지 않는 것이 포인트입니다. 이러한 경우 간단한게 다음과 같은 4가지 형태의 실행 계획이 나올 수 있습니다.

- Table_A를 구동 테이블로 Table_B와 결합하고 그 결과를 Table_C와 결합
- Table_A를 구동 테이블로 Table_C와 결합하고 그 결과를 Table_B와 결합
- Table_B를 구동 테이블로 Table_A와 결합하고 그 결과를 Table_C와 결합
- Table_C를 구동 테이블로 Table_A와 결합하고 그 결과를 Table_B와 결합

### Nested Loops가 선택되는 경우

여러 실행 계획이 나올 수 있는데, 예를 들면 다음과 같은 Nested Loops입니다.

(실행 계획)

### 크로스 결합이 선택되는 경우

그런데 이렇게 3개 이상의 테이블을 사용할 때 결합 조건이 없는 테이블들을 크로스 결합으로 결합해버리는 경우가 있습니다.

(실행 계획)

왜 이렇게 비효율적으로 보이는 크로스 결합이 선택될까요? 옵티마이저가 어떤 로직으로 실행 계획을 선택하는 지는 구현 의존적인 부분이 있으므로 추측에 불과하지만,  크로스 결합하는 두 테이블의 크기를 작다고 평가했을 가능성 때문일 수 있습니다. 두 테이블을 먼저 크로스 결합하고 결과를 다시 결합하는 것이 합리적일 수 있습니다.

이러한 작은 테이블 사이의 크로스 결합이 일어나는 현상은 두려워할 필요는 없습니다. 문제는 비교적 큰 테이블낄이 결합할 때 크로스 결합이 선택되는 경우입니다. 이는 단순히 테이블 크기가 클 뿐만 아니라, 검색 조건으로 히트되는 레코드 수가 많을 때도 발생합니다.

### 의도하지 않은 크로스 결합을 회피하는 방법

의도하지 않은 크로스 결합을 회피하는 방법으로는 결합 조건이 존재하지 않는 테이블 사이에 불필요한 결합 조건을 추가하는 방법이 있습니다. 현재의 예외 상황에서는 Table_B와 Table_C 사이에 결합 조건을 설정해준다는 것이지요.

이 방법은 Table_B와 Table_C 사이에 결합 조건을 설정할 수 있고, 결합 조건을 설정해도 결과에 아무런 영향도 주지 않는 경우에만 사용할 수 있습니다.

```sql
SELECT A.col_a, B.col_b, C.col_c
FROM Table_A A
INNER JOIN Table_B B
ON A.col_a = B.col_b
INNER JOIN Table_C C
ON A.col_ = C.col_c
AND C.col_c = B.col_b;
```

# 3. 결합이 느리다면

## 3-1. 상황에 따른 최적의 결합 알고리즘

Nested Loops, Hash, Sort Merge의 장점과 단점을 정리하면 다음과 같습니다.

| 이름 | 장점 | 단점 |
| --- | --- | --- |
| Nested Loops | - ‘작은 구동 테이블’ + ‘내부 테이블의 인덱스’라는 조건이 있으면 굉장히 빠르다
- 메모리 또는 디스크 소비가 적으므로 OLTP에 적합
- 비등가 결합에서도 사용 가능 | - 대규모 테이블들의 결합에는 부적합
- 내부 테이블의 인덱스가 사용되지 않거나, 내부 테이블의 선택률이 높으면 느리다 |
| Hash | - 대규모 테이블들을 결합할 때 적합 | - 메모리 소비량이 큰 OLTP에는 부적합
- 메모리 부족이 일어나면 TEMP 탈락 발생
- 등가 결합에서만 사용 가능 |
| Sort Merge | - 대규모 테이블들을 결합할 때 적합
- 비등가 결합에서도 사용 가능 | - 메모리 소비량이 큰 OLTP에는 부적합
- 메모리 부족이 일어나면 TEMP 탈락 발생
- 데이터가 정렬되어 있지 않다면 비효율적 |

옵티마이저도 이러한 장단점들을 비교하며 알고리즘을 선택하지만, 항상 최적의 결합 알고리즘을 선택하는 것은 아닙니다. 최적의 결합 알고리즘을 결합 대상 레코드 수의 관점에서 정리하면 대충 다음과 같습니다.

1. 소규모 - 소규모: 결합 대상 테이블이 작은 경우에는 어떤 알고리즘을 선택해도 크게 다르지 않습니다.
2. 소규모 - 대규모: 소규모 테이블을 구동 테이블로 하는 Nested Loops를 사용합니다. 대규모 테이블의 결합 키에 인덱스를 만들어줘야 합니다. 하지만 내부 테이블의 결합 대상 레코드가 너무 많다면 구동 테이블과 내부 테이블을 바꾸거나, Hash를 고려합니다.
3. 대규모 - 대규모: 일단 Hash를 사용합니다. 결합 키로 처음부터 정렬되어있는 상태라면 Sort Merge를 사용합니다.

## 3-2. 실행 계획 제어

원칙적으로는 옵티마이저가 자동으로 세우는 실행 계획을 사용자가 어떻게 바꿀 수 있을까요?

### DBMS별 실행 계획 제어

- Oracle: 힌트 구로 결합 알고리즘을 제어할 수 있습니다. 구동 테이블도 지정할 수 있습니다.
- Microsoft SQL Server: 힌트 구로 결합 알고리즘을 제어할 수 있습니다.
- PostgreSQL: pg_hint_plan 기능을 사용해 힌트 구처럼 결합 알고리즘을 제어할 수 있습니다. 또한 데이터베이스 전체 제어도 할 수 있습니다.
- MySQL: 결합 알고리즘 자체가 Nested Loops 계열밖에 없으므로 선택의 여지가 없습니다.

 

### 실행 계획을 사용자가 제어할 때의 리스크

그런데 힌트 구문과 매개변수를 사용해 실행 계획을 사용자가 제어할 때는 리스크가 따릅니다. 데이터양과 카디널리티는 데이터베이스를 운용하면서 계속 바뀌기 떼문에, 어떤 시점에는 적절했던 실행 계획이 또 다른 시점에선 그렇지 않을 수 있습니다.

그래서 사용자가 실행 계획을 제어할 때는 이러한 위험을 충분히 검토하고, 시스템의 미래 상황도 예측해서 적절한 실행 계획을 선택해야 합니다.

## 3-3. 흔들리는 실행 계획

개발자의 실패로 인해 잘못된 실행 계획이 선택될 수 있습니다. 하지만, 옵티마이저 역시 최적의 실행 계획을 선택하지 못할 수도 있습니다.

대표적인 ‘옵티마이저의 실패’는 장기적인 운용 중에 실행 계획이 안 좋은 방향으로 변화해버리는 것입니다. 데이터양의 증가 등에 따라 통계 정보가 변했을 때, 일정한 역치를 넘으면 옵티마이저가 실행 계획을 변화시키면서 일어납니다. 

이러한 실행 계획 변동이 일어나기 가장 쉬운 연산이 결합입니다. 여러 알고리즘이 선택될 수 있기 때문입니다. 따라서 SQL 성능의 변동 위험을 줄이려면 되도록 결합을 피해야 합니다. 비정규화 뿐만 아니라 다른 여러 결합을 회피하는 방식들이 있습니다. 이 책의 후반부에서 살펴볼 수 있을 것입니다.

# 4. 추가 공부 - MySQL의 결합

## 4-1. JOIN의 순서와 인덱스

인덱스 레인지 스캔은 인덱스를 탐색하는 단계외 인덱스를 스캔하는 과정으로 구분해볼 수 있습니다. 일반적으로 인덱스를 이용해 가져오는 레코드 건수는 적기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편입니다.

조인 작업에서 드라이빙 테이블(구동 테이블)을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 됩니다. 하지만 드리븐 테이블(내부 테이블)에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복합니다. 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립합니다.

조인 대상이 되는 두 테이블의 조인 키가 되는 칼럼에 인덱스가 있는지 없는지에 따라 조인 순서가 어떻게 달라지는지 살펴보겠습니다.

- 두 칼럼 모두 인덱스가 있는 경우: 어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있습니다. 옵티마이저는 통계 정보를 이용해 적절히 드라이빙 테이블을 선택합니다.
- 한쪽 칼럼에만 인덱스가 있는 경우: 만약 인덱스가 없는 테이블이 드리븐 테이블로 선택된다면 드라이빙 테이블의 레코드 건수만큼 드리븐 테이블을 풀 스캔해야만 조인 조건에 만족하는 레코드를 찾을 수 있습니다.  그래서 옵티마이저는 항상 인덱스가 없는 테이블을 드라이빙 테이블로 선택하고, 인덱스가 있는 테이블을 드리븐 테이블로 선택합니다.
- 두 칼럼 모두 인덱스가 없는 경우: 어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택합니다. 단 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적입니다. MySQL 8.0.18 이전 버전까지는 블록 네스티드 루프 조인을 사용했습니다. 하지만 8.0.18부터는 블록 네스티드 루프 조인이 없어지고 해시 조인으로 처리됩니다.

```sql
CREATE TABLE Shop
(id BIGINT,
 name VARCHAR(32));

CREATE TABLE Orders
(id BIGINT,
 shop_id BIGINT);
```

```sql
INSERT INTO Shop values(1, 'a'), (2, 'b');

INSERT INTO Orders values(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 2), (9, 2), (10, 2);

SELECT S.id, S.name, O.id
FROM Orders O INNER JOIN Shop S on O.shop_id = S.id;
```

(실행 계획)

```sql
INSERT INTO Shop values(1, 'a'), (2, 'b'), (3, 'b'), (4, 'b'), (5, 'b'), (6, 'b'), (7, 'b'), (8, 'b'), (9, 'b'), (10, 'b'), (11, 'b'), (12, 'b'), (13, 'b');

INSERT INTO Orders values(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 2), (9, 2), (10, 2);

SELECT S.id, S.name, O.id
FROM Orders O INNER JOIN Shop S on O.shop_id = S.id;
```

(실행 계획)

(추가적으로 해본 실험: Shop에 pk(인덱스) 제약조건 걸고 조인문 다시 실행 → 여전히 Hash Join / Orders에 pk(인덱스) 제약조건 걸고 조인문 다시 실행 → 여전히 Hash Join / 조인 조건에 들어가는 O.shop_id에도 인덱스 걸고 다시 실행 → Index Scan & Nested Loops)

## 4-2. MySQL의 Join 알고리즘

[MySQL8 해시조인(Hash Join)](https://hoing.io/archives/14457)

https://dev.mysql.com/doc/refman/8.2/en/explain-output.html#explain_extra
